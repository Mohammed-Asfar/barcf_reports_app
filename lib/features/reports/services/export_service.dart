import 'dart:io';
import 'package:csv/csv.dart';
import 'package:file_picker/file_picker.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'package:intl/intl.dart';
import '../models/issue_model.dart';
import '../models/user_model.dart';

class ExportService {
  static Future<void> exportToCsv(List<Issue> issues) async {
    // Sort issues by date ascending (oldest first, newest last)
    final sortedIssues = List<Issue>.from(issues)
      ..sort((a, b) => a.date.compareTo(b.date));

    List<List<dynamic>> rows = [];
    // Full details header
    rows.add([
      "S.No",
      "Date",
      "Name",
      "Emp No",
      "Purpose",
      "Problem",
      "Issue Sorted",
      "Materials Replaced",
      "Attended By",
      "Created At",
      "Updated At"
    ]);

    for (int i = 0; i < sortedIssues.length; i++) {
      final issue = sortedIssues[i];
      rows.add([
        i + 1, // Sequential S.No starting from 1
        DateFormat('dd-MM-yyyy').format(issue.date),
        issue.name,
        issue.empNo,
        issue.purpose,
        issue.problem,
        issue.isIssueSorted ? "Yes" : "No",
        issue.materialsReplaced ?? 'None',
        issue.attendedBy,
        issue.createdAt != null
            ? DateFormat('dd-MM-yyyy HH:mm').format(issue.createdAt!)
            : '',
        issue.updatedAt != null
            ? DateFormat('dd-MM-yyyy HH:mm').format(issue.updatedAt!)
            : '',
      ]);
    }

    String csv = const ListToCsvConverter().convert(rows);

    String? outputFile = await FilePicker.platform.saveFile(
      dialogTitle: 'Save CSV',
      fileName:
          'barcf_reports_${DateFormat('yyyyMMdd_HHmm').format(DateTime.now())}.csv',
      allowedExtensions: ['csv'],
      type: FileType.custom,
    );

    if (outputFile != null) {
      if (!outputFile.endsWith('.csv')) outputFile += '.csv';
      final file = File(outputFile);
      await file.writeAsString(csv);
    }
  }

  static Future<void> exportToPdf(List<Issue> issues, User user) async {
    // Sort issues by date ascending (oldest first, newest last)
    final sortedIssues = List<Issue>.from(issues)
      ..sort((a, b) => a.date.compareTo(b.date));

    final doc = pw.Document();

    doc.addPage(
      pw.MultiPage(
        // Landscape A4 for full details
        pageFormat: PdfPageFormat.a4.landscape,
        margin: const pw.EdgeInsets.all(20),
        build: (pw.Context context) {
          return [
            // Header
            pw.Container(
              padding: const pw.EdgeInsets.only(bottom: 10),
              decoration: const pw.BoxDecoration(
                border: pw.Border(
                  bottom: pw.BorderSide(width: 1, color: PdfColors.grey400),
                ),
              ),
              child: pw.Row(
                mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                children: [
                  pw.Text('BARCF AMC&NON AMC PC Reports',
                      style: pw.TextStyle(
                          fontSize: 18, fontWeight: pw.FontWeight.bold)),
                  pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.end,
                    children: [
                      pw.Text('Generated by: ${user.username}',
                          style: const pw.TextStyle(fontSize: 10)),
                      pw.Text(
                          'Date: ${DateFormat('dd-MM-yyyy HH:mm').format(DateTime.now())}',
                          style: const pw.TextStyle(fontSize: 10)),
                      pw.Text('Total Records: ${sortedIssues.length}',
                          style: const pw.TextStyle(fontSize: 10)),
                    ],
                  ),
                ],
              ),
            ),
            pw.SizedBox(height: 15),
            // Full details table
            pw.Table.fromTextArray(
              context: context,
              border: pw.TableBorder.all(color: PdfColors.grey400),
              headerStyle: pw.TextStyle(
                fontWeight: pw.FontWeight.bold,
                fontSize: 9,
                color: PdfColors.white,
              ),
              headerDecoration: const pw.BoxDecoration(
                color: PdfColors.blueGrey800,
              ),
              cellStyle: const pw.TextStyle(fontSize: 8),
              cellPadding:
                  const pw.EdgeInsets.symmetric(horizontal: 4, vertical: 3),
              cellAlignments: {
                0: pw.Alignment.center,
                1: pw.Alignment.center,
                6: pw.Alignment.center,
              },
              columnWidths: {
                0: const pw.FixedColumnWidth(35), // S.No
                1: const pw.FixedColumnWidth(70), // Date
                2: const pw.FlexColumnWidth(1.2), // Name
                3: const pw.FixedColumnWidth(50), // Emp No
                4: const pw.FlexColumnWidth(1), // Purpose
                5: const pw.FlexColumnWidth(2), // Problem
                6: const pw.FixedColumnWidth(45), // Status
                7: const pw.FlexColumnWidth(1.2), // Materials
                8: const pw.FlexColumnWidth(1), // Attended By
              },
              headers: [
                'S.No',
                'Date',
                'Name',
                'Emp No',
                'Purpose',
                'Problem',
                'Status',
                'Materials Replaced',
                'Attended By'
              ],
              data: sortedIssues.asMap().entries.map((entry) {
                final index = entry.key;
                final issue = entry.value;
                return [
                  (index + 1).toString(), // Sequential S.No starting from 1
                  DateFormat('dd-MM-yyyy').format(issue.date),
                  issue.name,
                  issue.empNo,
                  issue.purpose,
                  issue.problem,
                  issue.isIssueSorted ? 'Resolved' : 'Pending',
                  issue.materialsReplaced ?? 'None',
                  issue.attendedBy,
                ];
              }).toList(),
            ),
            pw.SizedBox(height: 20),
            // Footer summary
            pw.Container(
              padding: const pw.EdgeInsets.all(10),
              decoration: pw.BoxDecoration(
                color: PdfColors.grey200,
                borderRadius: pw.BorderRadius.circular(5),
              ),
              child: pw.Row(
                mainAxisAlignment: pw.MainAxisAlignment.spaceAround,
                children: [
                  pw.Text('Total Issues: ${sortedIssues.length}',
                      style: pw.TextStyle(
                          fontSize: 10, fontWeight: pw.FontWeight.bold)),
                  pw.Text(
                      'Resolved: ${sortedIssues.where((i) => i.isIssueSorted).length}',
                      style: pw.TextStyle(
                          fontSize: 10, fontWeight: pw.FontWeight.bold)),
                  pw.Text(
                      'Pending: ${sortedIssues.where((i) => !i.isIssueSorted).length}',
                      style: pw.TextStyle(
                          fontSize: 10, fontWeight: pw.FontWeight.bold)),
                ],
              ),
            ),
          ];
        },
      ),
    );

    await Printing.layoutPdf(
      onLayout: (PdfPageFormat format) async => doc.save(),
      name: 'BARCF_Report_${DateFormat('yyyyMMdd').format(DateTime.now())}',
    );
  }
}
